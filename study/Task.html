{% extends "global/Page.html" %}
{% load staticfiles otree %}

{% block styles %}
<style type="text/css">

    .otree-content.container,
.otree-body.container,
.otree-timer.alert {
    max-width: 90vw;
    width: 90vw;
}

.otree-timer.alert {
    border-radius: 0;
    padding: 1rem 2rem;
}

.otree-content{
    width:90vw;
    max-width: 90vw;
    background-color: rgb(255 255 255);
}

.page-header{
    margin: 0
}

.otree-body{
    margin-left:5vw;
}

.otree-form-errors{
    display: none;
    border: 1px solid rgb(255, 217, 204);
    background-color: rgb(255, 179, 153);
    text-align: center;

}

.success-message {
    border: 1px solid rgb(204, 238, 204);
    background-color: rgb(217, 255, 217);
    color: rgb(0, 100, 0);
    text-align: center;
}

.task-container{
    display: grid;
    width: min(95%, 1200px);
    margin: 2rem auto;
    border: 1px solid rgb(226, 238, 221);
    padding: 10px;
    align-items: center;
    justify-items: center;
}

.task-subcontainer{
    display: grid;
    width: auto;
    margin: auto;
    align-items: center;
    justify-items: center;
    grid-template-columns: auto repeat({{letters_per_word}}, auto);
    grid-template-rows: 1fr 1fr;
    grid-column-gap: 1vw;
    grid-row-gap: 0.5vw;
}

.legend{
    display: grid;
    grid-template-columns: repeat(26, 1em);
    grid-template-rows: 1;
    grid-column-gap: 0vw;
}

.legend-letter{
    font-size: 1.5vw;
    background-color: #cccccc;
}

.legend-code{
    font-size: 1.5vw;
}

.task-letter{
    font-size: 2vw;
    text-align: center;
    background-color: rgb(196, 221, 187);
    width: 100%;
    height: 100%;
      display: flex;
  align-items: center;
  justify-content: center;

}

.task-code{
    font-size: 1.8vw;
    width: 3em;
}

.test{
  display: block;
}

table, td, th {
  border: 1px solid black;
}

table {
  border-collapse: collapse;
  width: 100%;
}

th {
  font-size: 2vw;
  height: 2ex;
  text-align: center;
  background-color: rgb(200, 200, 200);
}

td {
  font-size: 1.5vw;
  height: 3.5ex;
  text-align: center;
}

.button-container{
    display: grid;
    grid-template-columns: 6em auto;
    grid-template-rows: 1;
    grid-column-gap: 1vw
}

#next-button{
    display: none;
}

</style>
{% endblock %}



{% block title %}
    Task
{% endblock %}

{% block content %}
<input type="hidden" name="performance" id="performance"><span hidden>{{ form.performance.errors }}</span>
<input type="hidden" name="mistakes" id="mistakes"> <span hidden>{{ form.mistakes.errors }}</span>

<p>
    Your performance so far: <span id="performance-display">{{ player.performance }}</span>  tasks.
</p>

<div class="test" id="hide_task">

<!-- alarm sound input-->
<audio id="alarm-sound" preload="auto" style="display:none">
  <source src="{% static 'alarm.mp3' %}" type="audio/mpeg">
</audio>

<!-- linkclick tracker-->
<input type="hidden" name="link_click_count"
       id="link_click_count" value="{{ player.link_click_count }}">
<!-- duration tracker-->
<input
  type="hidden"
  name="active_tab_seconds"
  id="active_tab_seconds"
  value="{{ player.active_tab_seconds }}">

<!-- link fields -->
<div style="margin-top: 20px;">
    <p><strong>You may visit these pages instead of working on the task:</strong></p>
    <ul>
        <li><a href="https://www.youtube.com" target="_blank">YouTube</a></li>
        <li><a href="https://www.instagram.com" target="_blank">Instagram</a></li>
        <li><a href="https://www.bbc.com/news" target="_blank">News</a></li>
    </ul>
</div>

<!-- <form id="test_frm"> -->
<div class="task-container">
    <div class="task-subcontainer" id="task-subcontainer">
        <div style="font-size: 1.8vw">Word: &nbsp;&nbsp;&nbsp;&nbsp;   </div>
            {% for l in task_list%}
                <div class="task-letter" id="task_letter_{{l}}"></div>
            {% endfor %}
            <div style="font-size: 1.8vw">Code:   &nbsp;&nbsp;&nbsp;&nbsp;  </div>
            {% for l in task_list%}
                <input class="task-code" id="task_code_{{l}}" type="number" onkeypress="return event.keyCode!=13">
            {% endfor %}
    </div>
</div>


<br><br>
<div class="button-container">
    <input type="button" id="submit-solution" onclick="myFunction()" value="Submit">
    <div class="otree-form-errors" id="error-form"></div>
    <input type="submit" id="next-button" name="next" value="Next">
</div>

<br><br>

<table>
<tr>
 {% for l in legend_list %}
<td id="llid_{{l}}"></td>
{% endfor%}
</tr>
<tr>
    {% for l in legend_list %}
<td id="lcid_{{l}}"></td>
{% endfor%}
</tr>
</table>

<br><br>
</div>


<script>

    let dict = {};
    let word = [];

  const letters_per_word = {{letters_per_word| safe}};
  const alphabet = genCharArray('A', 'Z');
  const legend_letters = alphabet;
  const word_letters = alphabet;
  const required_tasks = js_vars.required_tasks;

// Enforce lockout if participant already completed required tasks
document.addEventListener("DOMContentLoaded", () => {
    const performance = Number(document.getElementById("performance").value);
    if (performance >= required_tasks) {
        disableTaskInputs();
        document.getElementById("submit-solution").disabled = true;

        const msgBox = document.getElementById("error-form");
        msgBox.classList.remove("otree-form-errors");
        msgBox.classList.add("success-message");
        msgBox.innerText =
            "You have completed all required tasks. You can browse other pages until time runs out.";
        msgBox.style.display = "block";
    }
});

document.addEventListener("DOMContentLoaded", () => {
    liveSend({ init: true, pageLoad: true });
});

document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
        liveSend({ request_update: true });
    }
});

/// --- Unlock alarm audio on first user interaction (click / key / move)
function unlockAudio() {
    const alarm = document.getElementById('alarm-sound');
    if (alarm) {
        alarm.play()
            .then(() => {
                alarm.pause();
                alarm.currentTime = 0;
            })
            .catch(() => {
                // ignore any autoplay restriction errors
            });
    }
}

// Listen to several possible user interactions to unlock audio once
['click', 'keydown', 'mousemove'].forEach(evt => {
    document.addEventListener(evt, unlockAudio, { once: true });
});

function myFunction() {
    let errors = checkSolution(letters_per_word);

    if (errors === 0) {
        let temp = Number(document.getElementById("performance").value) + 1;
        document.getElementById("performance").value = temp;
        document.getElementById("error-form").style.display = "none";

        let performance = Number(document.getElementById("performance").value);
        document.getElementById("performance-display").innerText = performance;
        liveSend({ 'performance': performance });
        document.getElementById("task_code_0").focus();

        // âœ… If they reached or exceeded required tasks, lock inputs & stop further work
        if (performance >= required_tasks) {
            disableTaskInputs();
            document.getElementById("submit-solution").disabled = true;
            const msgBox = document.getElementById("error-form");
            msgBox.classList.remove("otree-form-errors"); // remove red styling
            msgBox.classList.add("success-message");       // apply green style
            msgBox.innerText =
                "You have completed all required tasks. You can browse other pages until time runs out.";
            msgBox.style.display = "block";
            return; // do NOT auto-submit or generate a new dict
        }

        // Otherwise, generate new task normally
        let dict = genNewDict();
        shuffle(legend_letters);

        for (let i = 0; i <= 25; i++) {
            document.getElementById("llid_" + i).innerText = legend_letters[i];
            document.getElementById("lcid_" + i).innerText = dict[legend_letters[i]];
        }

        let word = genNewWord(letters_per_word, word_letters);
        for (let i = 0; i < letters_per_word; i++) {
            document.getElementById("task_letter_" + i).innerText = word[i];
            document.getElementById("task_code_" + i).value = '';
        }
    }

    else if (errors > 0) {
        let temp = Number(document.getElementById("mistakes").value) + 1;
        document.getElementById("mistakes").value = temp;
        liveSend({ mistakes: temp });
        const msgBox = document.getElementById("error-form");
        msgBox.classList.remove("success-message");
        msgBox.classList.add("otree-form-errors");
        msgBox.innerText =
            errors === 1
                ? "There is 1 mistake."
                : "There are " + errors + " mistakes.";
        msgBox.style.display = "block";
    }
}

function disableTaskInputs() {
    for (let i = 0; i < letters_per_word; i++) {
        document.getElementById("task_code_" + i).disabled = true;
    }
}

function checkSolution(letters_per_word) {
    let answers = [];
    let errors = 0;
    for (let i = 0; i < letters_per_word; i++) {
        answers[i] = Number(document.getElementById("task_code_"+i).value);
        if (dict[word[i]] != answers[i]) {errors += 1}
    }
    return errors
}

function genNewWord(letters_per_word, word_letters) {
    shuffle(word_letters)
    let word = [];
      for (let i = 0; i < letters_per_word; i++) {
           word[i] = word_letters[i];
       }
    return word
}

function genCharArray(charA, charZ) {
    let a = [], i = charA.charCodeAt(0), j = charZ.charCodeAt(0);
    for (; i <= j; ++i) {
        a.push(String.fromCharCode(i));
    }
    return a;
}

function shuffle(a) {
    let j, x, i;
    let b=a;
    for (i = b.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = b[i];
        b[i] = b[j];
        b[j] = x;
    }
    return a;
}

function randomDataSet(dataSetSize, minValue, maxValue) {
  return new Array(dataSetSize).fill(0).map(function(n) {
    return Math.floor(Math.random() * (maxValue - minValue) + minValue);
  });
}

function genNewDict() {
    const dict = {};
    const letters = genCharArray('A', 'Z');
    for (const letter of letters) {
        dict[letter] = Math.floor(Math.random() * 900) + 100; // 100â€“999
    }
    return dict;
}

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function liveRecv(data) {
    // --- Back-button / reload protection: forced redirect ---
    if (data.redirect) {
        const nextBtn = document.getElementById("next-button");
        if (nextBtn) {
            nextBtn.click();
        }
        return; // don't process anything else
    }
    // --- Always update counters ---
    if (typeof data.performance === 'number') {
        document.getElementById("performance").value = data.performance;
        document.getElementById("performance-display").innerText = data.performance;
    }
    if (typeof data.mistakes === 'number') {
        document.getElementById("mistakes").value = data.mistakes;
    }
    if (typeof data.link_click_count === 'number') {
        document.getElementById("link_click_count").value = data.link_click_count;
    }
    if (typeof data.active_tab_seconds === 'number') {
        document.getElementById("active_tab_seconds").value = data.active_tab_seconds;
    }

    // --- Only repaint task when we actually have a new one ---
    if (data.dict && data.word && data.shuffle) {
        dict = data.dict;
        word = data.word;

        const letters = genCharArray('A', 'Z');
        for (let i = 0; i < 26; i++) {
            const L = letters[i];
            document.getElementById("llid_" + i).innerText = L;
            document.getElementById("lcid_" + i).innerText = dict[L];
        }

        for (let i = 0; i < letters_per_word; i++) {
            document.getElementById("task_letter_" + i).innerText = word[i];
            document.getElementById("task_code_" + i).value = '';
        }
        document.getElementById("task_code_0").focus();
    }
    // --- For init: also paint if shuffle flag missing but dict+word exist ---
    else if (data.dict && data.word && !data.hasOwnProperty('shuffle')) {
        dict = data.dict;
        word = data.word;

        const letters = genCharArray('A', 'Z');
        for (let i = 0; i < 26; i++) {
            const L = letters[i];
            document.getElementById("llid_" + i).innerText = L;
            document.getElementById("lcid_" + i).innerText = dict[L];
        }

        for (let i = 0; i < letters_per_word; i++) {
            document.getElementById("task_letter_" + i).innerText = word[i];
        }
        document.getElementById("task_code_0").focus();
    }

    if (Number(document.getElementById("performance").value) >= required_tasks) {
        disableTaskInputs();
        document.getElementById("submit-solution").disabled = true;
        return; // do NOT overwrite UI with new dict/word
    }
}

document.getElementById("submit-solution")
    .addEventListener("keyup", function(e) {
        if (e.keyCode === 13) {
            document.getElementById("submit-solution").click();
        }
    });

// --- Bell Reminder Logic ---
// Rings 5 seconds before timeout ONLY if the tab is hidden at that moment.
document.addEventListener('DOMContentLoaded', () => {
    const alarm = document.getElementById('alarm-sound');
    const totalSeconds = js_vars.timeout_seconds;
    const reminderThreshold = totalSeconds - 5;
    const startTime = Date.now();
    let reminderTriggered = false;

    // unlock audio after first interaction
    function unlockAudio() {
        if (alarm) {
            alarm.play().then(() => {
                alarm.pause();
                alarm.currentTime = 0;
            }).catch(() => {});
        }
    }
    ['click', 'keydown', 'mousemove'].forEach(evt => {
        document.addEventListener(evt, unlockAudio, { once: true });
    });

    // simple timer that checks once per second
    let secondsElapsed = 0;
    const tick = setInterval(() => {
        secondsElapsed++;
        // at 5 s before timeout, check visibility
        if (secondsElapsed >= reminderThreshold && !reminderTriggered) {
            reminderTriggered = true;
            if (document.visibilityState === 'hidden') {
                triggerReminder();
            }
            clearInterval(tick);
        }
    }, 1000);

function triggerReminder() {
    const body = document.body;
    const originalBg = body.style.backgroundColor;

    // background flash
    body.style.backgroundColor = '#ffcccc';
    setTimeout(() => (body.style.backgroundColor = originalBg), 2000);

    // ðŸ”” play sound
    if (alarm) alarm.play().catch(() => {});

    // ðŸ” title blink
    const originalTitle = document.title;
    let toggle = false;

    const blinkInterval = setInterval(() => {
        document.title = toggle ? 'â° Timeâ€™s up!' : originalTitle;
        toggle = !toggle;
    }, 1000);

    // stop blinking when user returns focus (optional but nice)
    document.addEventListener(
        'visibilitychange',
        () => {
            if (document.visibilityState === 'visible') {
                clearInterval(blinkInterval);
                document.title = originalTitle;
            }
        },
        { once: true }
    );
}

    // fallback: if the browser throttled the timer while hidden,
    // ring as soon as the user comes back *and* time is already past threshold
    document.addEventListener('visibilitychange', () => {
        if (
            document.visibilityState === 'visible' &&
            !reminderTriggered
        ) {
            const now = Date.now();
            const elapsed = (now - startTime) / 1000;
            if (elapsed >= reminderThreshold) {
                reminderTriggered = true;
                triggerReminder();
            }
        }
    });
});

// Listen for any link click and mark the hidden field
document.querySelectorAll('a').forEach(link => {
  link.addEventListener('click', () => {
    const inp = document.getElementById('link_click_count');
    const newCount = parseInt(inp.value, 10) + 1;
    inp.value = newCount;
    liveSend({ link_click_count: newCount });
  });
});


  // initialize from hidden input (or zero)
  let activeTabSeconds = parseInt(
    document.getElementById("active_tab_seconds").value,
    10
  ) || 0;

  // every second, if this tab is focused, increment + liveSend
  setInterval(() => {
    if (document.hasFocus()) {
      activeTabSeconds++;
      document.getElementById("active_tab_seconds").value = activeTabSeconds;
      liveSend({ active_tab_seconds: activeTabSeconds });
    }
  }, 1000);

</script>

{% endblock %}